//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v13.18.2.0 (NJsonSchema v10.8.0.0 (Newtonsoft.Json v11.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------

/* tslint:disable */
/* eslint-disable */
// ReSharper disable InconsistentNaming

import { mergeMap as _observableMergeMap, catchError as _observableCatch } from 'rxjs/operators';
import { Observable, throwError as _observableThrow, of as _observableOf } from 'rxjs';
import { Injectable, Inject, Optional, InjectionToken } from '@angular/core';
import { HttpClient, HttpHeaders, HttpResponse, HttpResponseBase } from '@angular/common/http';

import * as moment from 'moment';

export const API_BASE_URL = new InjectionToken<string>('API_BASE_URL');

export interface ICharactersService {
    getAll(): Observable<CharacterView[]>;
    get(name: string): Observable<CharacterView>;
}

@Injectable({
    providedIn: 'root'
})
export class CharactersService implements ICharactersService {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "http://localhost:5295";
    }

    getAll(): Observable<CharacterView[]> {
        let url_ = this.baseUrl + "/characters";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CharacterView[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CharacterView[]>;
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<CharacterView[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(CharacterView.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    get(name: string): Observable<CharacterView> {
        let url_ = this.baseUrl + "/characters/{name}";
        if (name === undefined || name === null)
            throw new Error("The parameter 'name' must be defined.");
        url_ = url_.replace("{name}", encodeURIComponent("" + name));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CharacterView>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CharacterView>;
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<CharacterView> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CharacterView.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

export interface ICombatsService {
    getCombatInPreparation(id: string, playerName?: string | undefined): Observable<CombatInPreparationView>;
    updateCombatInPreparation(id: string, request: UpdateCombatInPreparationRequest): Observable<void>;
    getCombatsInPreparationOfPlayer(playerName?: string | undefined): Observable<CombatInPreparationView[]>;
    createCombat(playerName?: string | undefined): Observable<CombatInPreparationView>;
    getCombatsOfPlayer(playerName?: string | undefined): Observable<PlayerCombatView[]>;
    updateCombatInPreparationSide(id: string, request: UpdateCombatInPreparationSideRequest): Observable<void>;
    leaveCombatInPreparation(id: string, playerName?: string | undefined): Observable<FileResponse | null>;
    startCombat(id: string, playerName?: string | undefined): Observable<string>;
    getCombat(id: string, playerName?: string | undefined): Observable<PlayerCombatView>;
    playCard(id: string, index: number, playerName?: string | undefined): Observable<FileResponse | null>;
    endTurn(id: string, playerName?: string | undefined): Observable<FileResponse | null>;
}

@Injectable({
    providedIn: 'root'
})
export class CombatsService implements ICombatsService {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "http://localhost:5295";
    }

    getCombatInPreparation(id: string, playerName?: string | undefined): Observable<CombatInPreparationView> {
        let url_ = this.baseUrl + "/combats/in-preparation/{id}?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (playerName === null)
            throw new Error("The parameter 'playerName' cannot be null.");
        else if (playerName !== undefined)
            url_ += "playerName=" + encodeURIComponent("" + playerName) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetCombatInPreparation(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCombatInPreparation(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CombatInPreparationView>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CombatInPreparationView>;
        }));
    }

    protected processGetCombatInPreparation(response: HttpResponseBase): Observable<CombatInPreparationView> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CombatInPreparationView.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    updateCombatInPreparation(id: string, request: UpdateCombatInPreparationRequest): Observable<void> {
        let url_ = this.baseUrl + "/combats/in-preparation/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateCombatInPreparation(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateCombatInPreparation(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processUpdateCombatInPreparation(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getCombatsInPreparationOfPlayer(playerName?: string | undefined): Observable<CombatInPreparationView[]> {
        let url_ = this.baseUrl + "/combats/in-preparation?";
        if (playerName === null)
            throw new Error("The parameter 'playerName' cannot be null.");
        else if (playerName !== undefined)
            url_ += "playerName=" + encodeURIComponent("" + playerName) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetCombatsInPreparationOfPlayer(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCombatsInPreparationOfPlayer(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CombatInPreparationView[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CombatInPreparationView[]>;
        }));
    }

    protected processGetCombatsInPreparationOfPlayer(response: HttpResponseBase): Observable<CombatInPreparationView[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(CombatInPreparationView.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    createCombat(playerName?: string | undefined): Observable<CombatInPreparationView> {
        let url_ = this.baseUrl + "/combats?";
        if (playerName === null)
            throw new Error("The parameter 'playerName' cannot be null.");
        else if (playerName !== undefined)
            url_ += "playerName=" + encodeURIComponent("" + playerName) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateCombat(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateCombat(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CombatInPreparationView>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CombatInPreparationView>;
        }));
    }

    protected processCreateCombat(response: HttpResponseBase): Observable<CombatInPreparationView> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CombatInPreparationView.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getCombatsOfPlayer(playerName?: string | undefined): Observable<PlayerCombatView[]> {
        let url_ = this.baseUrl + "/combats?";
        if (playerName === null)
            throw new Error("The parameter 'playerName' cannot be null.");
        else if (playerName !== undefined)
            url_ += "playerName=" + encodeURIComponent("" + playerName) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetCombatsOfPlayer(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCombatsOfPlayer(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PlayerCombatView[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PlayerCombatView[]>;
        }));
    }

    protected processGetCombatsOfPlayer(response: HttpResponseBase): Observable<PlayerCombatView[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(PlayerCombatView.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    updateCombatInPreparationSide(id: string, request: UpdateCombatInPreparationSideRequest): Observable<void> {
        let url_ = this.baseUrl + "/combats/in-preparation/{id}/side";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateCombatInPreparationSide(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateCombatInPreparationSide(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processUpdateCombatInPreparationSide(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    leaveCombatInPreparation(id: string, playerName?: string | undefined): Observable<FileResponse | null> {
        let url_ = this.baseUrl + "/combats/in-preparation/{id}/leave?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (playerName === null)
            throw new Error("The parameter 'playerName' cannot be null.");
        else if (playerName !== undefined)
            url_ += "playerName=" + encodeURIComponent("" + playerName) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processLeaveCombatInPreparation(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processLeaveCombatInPreparation(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse | null>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse | null>;
        }));
    }

    protected processLeaveCombatInPreparation(response: HttpResponseBase): Observable<FileResponse | null> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    startCombat(id: string, playerName?: string | undefined): Observable<string> {
        let url_ = this.baseUrl + "/combats/{id}/start?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (playerName === null)
            throw new Error("The parameter 'playerName' cannot be null.");
        else if (playerName !== undefined)
            url_ += "playerName=" + encodeURIComponent("" + playerName) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processStartCombat(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processStartCombat(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<string>;
                }
            } else
                return _observableThrow(response_) as any as Observable<string>;
        }));
    }

    protected processStartCombat(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getCombat(id: string, playerName?: string | undefined): Observable<PlayerCombatView> {
        let url_ = this.baseUrl + "/combats/{id}?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (playerName === null)
            throw new Error("The parameter 'playerName' cannot be null.");
        else if (playerName !== undefined)
            url_ += "playerName=" + encodeURIComponent("" + playerName) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetCombat(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCombat(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PlayerCombatView>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PlayerCombatView>;
        }));
    }

    protected processGetCombat(response: HttpResponseBase): Observable<PlayerCombatView> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PlayerCombatView.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    playCard(id: string, index: number, playerName?: string | undefined): Observable<FileResponse | null> {
        let url_ = this.baseUrl + "/combats/{id}/play/{index}?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (index === undefined || index === null)
            throw new Error("The parameter 'index' must be defined.");
        url_ = url_.replace("{index}", encodeURIComponent("" + index));
        if (playerName === null)
            throw new Error("The parameter 'playerName' cannot be null.");
        else if (playerName !== undefined)
            url_ += "playerName=" + encodeURIComponent("" + playerName) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPlayCard(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPlayCard(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse | null>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse | null>;
        }));
    }

    protected processPlayCard(response: HttpResponseBase): Observable<FileResponse | null> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    endTurn(id: string, playerName?: string | undefined): Observable<FileResponse | null> {
        let url_ = this.baseUrl + "/combats/{id}/end-turn?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (playerName === null)
            throw new Error("The parameter 'playerName' cannot be null.");
        else if (playerName !== undefined)
            url_ += "playerName=" + encodeURIComponent("" + playerName) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processEndTurn(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processEndTurn(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse | null>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse | null>;
        }));
    }

    protected processEndTurn(response: HttpResponseBase): Observable<FileResponse | null> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

export class CharacterView implements ICharacterView {
    identity!: CharacterIdentity;
    statistics!: CharacterStatistics;
    deck!: ActionCardView[];

    constructor(data?: ICharacterView) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.identity = new CharacterIdentity();
            this.statistics = new CharacterStatistics();
            this.deck = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            this.identity = _data["identity"] ? CharacterIdentity.fromJS(_data["identity"]) : new CharacterIdentity();
            this.statistics = _data["statistics"] ? CharacterStatistics.fromJS(_data["statistics"]) : new CharacterStatistics();
            if (Array.isArray(_data["deck"])) {
                this.deck = [] as any;
                for (let item of _data["deck"])
                    this.deck!.push(ActionCardView.fromJS(item));
            }
        }
    }

    static fromJS(data: any): CharacterView {
        data = typeof data === 'object' ? data : {};
        let result = new CharacterView();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["identity"] = this.identity ? this.identity.toJSON() : <any>undefined;
        data["statistics"] = this.statistics ? this.statistics.toJSON() : <any>undefined;
        if (Array.isArray(this.deck)) {
            data["deck"] = [];
            for (let item of this.deck)
                data["deck"].push(item.toJSON());
        }
        return data;
    }
}

export interface ICharacterView {
    identity: CharacterIdentity;
    statistics: CharacterStatistics;
    deck: ActionCardView[];
}

export class CharacterIdentity implements ICharacterIdentity {
    name!: string;
    displayName!: string;
    description?: string | undefined;

    constructor(data?: ICharacterIdentity) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.displayName = _data["displayName"];
            this.description = _data["description"];
        }
    }

    static fromJS(data: any): CharacterIdentity {
        data = typeof data === 'object' ? data : {};
        let result = new CharacterIdentity();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["displayName"] = this.displayName;
        data["description"] = this.description;
        return data;
    }
}

export interface ICharacterIdentity {
    name: string;
    displayName: string;
    description?: string | undefined;
}

export class CharacterStatistics implements ICharacterStatistics {
    maxHealth!: number;

    constructor(data?: ICharacterStatistics) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.maxHealth = _data["maxHealth"];
        }
    }

    static fromJS(data: any): CharacterStatistics {
        data = typeof data === 'object' ? data : {};
        let result = new CharacterStatistics();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["maxHealth"] = this.maxHealth;
        return data;
    }
}

export interface ICharacterStatistics {
    maxHealth: number;
}

export class ActionCardView implements IActionCardView {
    name!: string;
    description?: string | undefined;
    apCost!: number;
    target!: ActionCardTarget;
    mainEffect!: EffectView;
    additionalEffects!: EffectView[];

    constructor(data?: IActionCardView) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.additionalEffects = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.description = _data["description"];
            this.apCost = _data["apCost"];
            this.target = _data["target"];
            this.mainEffect = _data["mainEffect"] ? EffectView.fromJS(_data["mainEffect"]) : <any>undefined;
            if (Array.isArray(_data["additionalEffects"])) {
                this.additionalEffects = [] as any;
                for (let item of _data["additionalEffects"])
                    this.additionalEffects!.push(EffectView.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ActionCardView {
        data = typeof data === 'object' ? data : {};
        let result = new ActionCardView();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["description"] = this.description;
        data["apCost"] = this.apCost;
        data["target"] = this.target;
        data["mainEffect"] = this.mainEffect ? this.mainEffect.toJSON() : <any>undefined;
        if (Array.isArray(this.additionalEffects)) {
            data["additionalEffects"] = [];
            for (let item of this.additionalEffects)
                data["additionalEffects"].push(item.toJSON());
        }
        return data;
    }
}

export interface IActionCardView {
    name: string;
    description?: string | undefined;
    apCost: number;
    target: ActionCardTarget;
    mainEffect: EffectView;
    additionalEffects: EffectView[];
}

export enum ActionCardTarget {
    None = "none",
    Self = "self",
    OtherAlly = "otherAlly",
    FrontOpponent = "frontOpponent",
    BackOpponent = "backOpponent",
    AllOpponents = "allOpponents",
    FrontAlly = "frontAlly",
    BackAlly = "backAlly",
    AllAllies = "allAllies",
}

export abstract class EffectView implements IEffectView {

    protected _discriminator: string;

    constructor(data?: IEffectView) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        this._discriminator = "EffectView";
    }

    init(_data?: any) {
    }

    static fromJS(data: any): EffectView {
        data = typeof data === 'object' ? data : {};
        if (data["effectType"] === "DamageEffectView") {
            let result = new DamageEffectView();
            result.init(data);
            return result;
        }
        if (data["effectType"] === "HealEffectView") {
            let result = new HealEffectView();
            result.init(data);
            return result;
        }
        if (data["effectType"] === "ShieldEffectView") {
            let result = new ShieldEffectView();
            result.init(data);
            return result;
        }
        if (data["effectType"] === "AddEnchantmentEffectView") {
            let result = new AddEnchantmentEffectView();
            result.init(data);
            return result;
        }
        if (data["effectType"] === "RandomEffectView") {
            let result = new RandomEffectView();
            result.init(data);
            return result;
        }
        throw new Error("The abstract class 'EffectView' cannot be instantiated.");
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["effectType"] = this._discriminator;
        return data;
    }
}

export interface IEffectView {
}

export class DamageEffectView extends EffectView implements IDamageEffectView {
    amount!: number;
    element!: Element;
    lifeStealRatio!: number;

    constructor(data?: IDamageEffectView) {
        super(data);
        this._discriminator = "DamageEffectView";
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.amount = _data["amount"];
            this.element = _data["element"];
            this.lifeStealRatio = _data["lifeStealRatio"];
        }
    }

    static override fromJS(data: any): DamageEffectView {
        data = typeof data === 'object' ? data : {};
        let result = new DamageEffectView();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["amount"] = this.amount;
        data["element"] = this.element;
        data["lifeStealRatio"] = this.lifeStealRatio;
        super.toJSON(data);
        return data;
    }
}

export interface IDamageEffectView extends IEffectView {
    amount: number;
    element: Element;
    lifeStealRatio: number;
}

export enum Element {
    Neutral = "neutral",
    Fire = "fire",
    Earth = "earth",
    Water = "water",
    Wind = "wind",
}

export class HealEffectView extends EffectView implements IHealEffectView {
    amount!: number;

    constructor(data?: IHealEffectView) {
        super(data);
        this._discriminator = "HealEffectView";
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.amount = _data["amount"];
        }
    }

    static override fromJS(data: any): HealEffectView {
        data = typeof data === 'object' ? data : {};
        let result = new HealEffectView();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["amount"] = this.amount;
        super.toJSON(data);
        return data;
    }
}

export interface IHealEffectView extends IEffectView {
    amount: number;
}

export class ShieldEffectView extends EffectView implements IShieldEffectView {
    amount!: number;

    constructor(data?: IShieldEffectView) {
        super(data);
        this._discriminator = "ShieldEffectView";
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.amount = _data["amount"];
        }
    }

    static override fromJS(data: any): ShieldEffectView {
        data = typeof data === 'object' ? data : {};
        let result = new ShieldEffectView();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["amount"] = this.amount;
        super.toJSON(data);
        return data;
    }
}

export interface IShieldEffectView extends IEffectView {
    amount: number;
}

export class AddEnchantmentEffectView extends EffectView implements IAddEnchantmentEffectView {
    enchantmentEffect!: EnchantmentView;

    constructor(data?: IAddEnchantmentEffectView) {
        super(data);
        if (!data) {
            this.enchantmentEffect = new EnchantmentView();
        }
        this._discriminator = "AddEnchantmentEffectView";
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.enchantmentEffect = _data["enchantmentEffect"] ? EnchantmentView.fromJS(_data["enchantmentEffect"]) : new EnchantmentView();
        }
    }

    static override fromJS(data: any): AddEnchantmentEffectView {
        data = typeof data === 'object' ? data : {};
        let result = new AddEnchantmentEffectView();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["enchantmentEffect"] = this.enchantmentEffect ? this.enchantmentEffect.toJSON() : <any>undefined;
        super.toJSON(data);
        return data;
    }
}

export interface IAddEnchantmentEffectView extends IEffectView {
    enchantmentEffect: EnchantmentView;
}

export class EnchantmentView implements IEnchantmentView {
    name!: string;
    passive!: PassiveEffectView[];
    triggered!: TriggeredEffectView[];

    constructor(data?: IEnchantmentView) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.passive = [];
            this.triggered = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            if (Array.isArray(_data["passive"])) {
                this.passive = [] as any;
                for (let item of _data["passive"])
                    this.passive!.push(PassiveEffectView.fromJS(item));
            }
            if (Array.isArray(_data["triggered"])) {
                this.triggered = [] as any;
                for (let item of _data["triggered"])
                    this.triggered!.push(TriggeredEffectView.fromJS(item));
            }
        }
    }

    static fromJS(data: any): EnchantmentView {
        data = typeof data === 'object' ? data : {};
        let result = new EnchantmentView();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        if (Array.isArray(this.passive)) {
            data["passive"] = [];
            for (let item of this.passive)
                data["passive"].push(item.toJSON());
        }
        if (Array.isArray(this.triggered)) {
            data["triggered"] = [];
            for (let item of this.triggered)
                data["triggered"].push(item.toJSON());
        }
        return data;
    }
}

export interface IEnchantmentView {
    name: string;
    passive: PassiveEffectView[];
    triggered: TriggeredEffectView[];
}

export class PassiveEffectView implements IPassiveEffectView {
    duration!: number;

    protected _discriminator: string;

    constructor(data?: IPassiveEffectView) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        this._discriminator = "PassiveEffectView";
    }

    init(_data?: any) {
        if (_data) {
            this.duration = _data["duration"];
        }
    }

    static fromJS(data: any): PassiveEffectView {
        data = typeof data === 'object' ? data : {};
        if (data["effectType"] === "CharacterStatsEffectView") {
            let result = new CharacterStatsEffectView();
            result.init(data);
            return result;
        }
        if (data["effectType"] === "CardStatsEffectView") {
            let result = new CardStatsEffectView();
            result.init(data);
            return result;
        }
        let result = new PassiveEffectView();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["effectType"] = this._discriminator;
        data["duration"] = this.duration;
        return data;
    }
}

export interface IPassiveEffectView {
    duration: number;
}

export class CharacterStatsEffectView extends PassiveEffectView implements ICharacterStatsEffectView {
    type!: CharacterStatEffectType;
    amount!: number;

    constructor(data?: ICharacterStatsEffectView) {
        super(data);
        this._discriminator = "CharacterStatsEffectView";
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.type = _data["type"];
            this.amount = _data["amount"];
        }
    }

    static override fromJS(data: any): CharacterStatsEffectView {
        data = typeof data === 'object' ? data : {};
        let result = new CharacterStatsEffectView();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["type"] = this.type;
        data["amount"] = this.amount;
        super.toJSON(data);
        return data;
    }
}

export interface ICharacterStatsEffectView extends IPassiveEffectView {
    type: CharacterStatEffectType;
    amount: number;
}

export enum CharacterStatEffectType {
    IncreaseAllDamages = "increaseAllDamages",
    ReduceAllDamages = "reduceAllDamages",
    IncreaseAllResistances = "increaseAllResistances",
    ReduceAllResistances = "reduceAllResistances",
}

export class CardStatsEffectView extends PassiveEffectView implements ICardStatsEffectView {
    type!: CardStatEffectType;
    amount!: number;

    constructor(data?: ICardStatsEffectView) {
        super(data);
        this._discriminator = "CardStatsEffectView";
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.type = _data["type"];
            this.amount = _data["amount"];
        }
    }

    static override fromJS(data: any): CardStatsEffectView {
        data = typeof data === 'object' ? data : {};
        let result = new CardStatsEffectView();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["type"] = this.type;
        data["amount"] = this.amount;
        super.toJSON(data);
        return data;
    }
}

export interface ICardStatsEffectView extends IPassiveEffectView {
    type: CardStatEffectType;
    amount: number;
}

export enum CardStatEffectType {
    IncreaseApCost = "increaseApCost",
    ReduceApCost = "reduceApCost",
    IncreaseDamage = "increaseDamage",
    ReduceDamage = "reduceDamage",
}

export class TriggeredEffectView implements ITriggeredEffectView {
    trigger!: EffectTriggerView;
    effect!: EffectView;

    constructor(data?: ITriggeredEffectView) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.trigger = new EffectTriggerView();
        }
    }

    init(_data?: any) {
        if (_data) {
            this.trigger = _data["trigger"] ? EffectTriggerView.fromJS(_data["trigger"]) : new EffectTriggerView();
            this.effect = _data["effect"] ? EffectView.fromJS(_data["effect"]) : <any>undefined;
        }
    }

    static fromJS(data: any): TriggeredEffectView {
        data = typeof data === 'object' ? data : {};
        let result = new TriggeredEffectView();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["trigger"] = this.trigger ? this.trigger.toJSON() : <any>undefined;
        data["effect"] = this.effect ? this.effect.toJSON() : <any>undefined;
        return data;
    }
}

export interface ITriggeredEffectView {
    trigger: EffectTriggerView;
    effect: EffectView;
}

export class EffectTriggerView implements IEffectTriggerView {

    protected _discriminator: string;

    constructor(data?: IEffectTriggerView) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        this._discriminator = "EffectTriggerView";
    }

    init(_data?: any) {
    }

    static fromJS(data: any): EffectTriggerView {
        data = typeof data === 'object' ? data : {};
        if (data["$type"] === "TurnTriggerView") {
            let result = new TurnTriggerView();
            result.init(data);
            return result;
        }
        let result = new EffectTriggerView();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["$type"] = this._discriminator;
        return data;
    }
}

export interface IEffectTriggerView {
}

export class TurnTriggerView extends EffectTriggerView implements ITurnTriggerView {
    moment!: TriggerMoment;
    duration!: number;
    initialDelay!: number;

    constructor(data?: ITurnTriggerView) {
        super(data);
        this._discriminator = "TurnTriggerView";
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.moment = _data["moment"];
            this.duration = _data["duration"];
            this.initialDelay = _data["initialDelay"];
        }
    }

    static override fromJS(data: any): TurnTriggerView {
        data = typeof data === 'object' ? data : {};
        let result = new TurnTriggerView();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["moment"] = this.moment;
        data["duration"] = this.duration;
        data["initialDelay"] = this.initialDelay;
        super.toJSON(data);
        return data;
    }
}

export interface ITurnTriggerView extends IEffectTriggerView {
    moment: TriggerMoment;
    duration: number;
    initialDelay: number;
}

export enum TriggerMoment {
    StartOfSourceTurn = "startOfSourceTurn",
    EndOfSourceTurn = "endOfSourceTurn",
    StartOfTargetTurn = "startOfTargetTurn",
    EndOfTargetTurn = "endOfTargetTurn",
}

export class RandomEffectView extends EffectView implements IRandomEffectView {
    entries!: RandomEffectEntryView[];

    constructor(data?: IRandomEffectView) {
        super(data);
        if (!data) {
            this.entries = [];
        }
        this._discriminator = "RandomEffectView";
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            if (Array.isArray(_data["entries"])) {
                this.entries = [] as any;
                for (let item of _data["entries"])
                    this.entries!.push(RandomEffectEntryView.fromJS(item));
            }
        }
    }

    static override fromJS(data: any): RandomEffectView {
        data = typeof data === 'object' ? data : {};
        let result = new RandomEffectView();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.entries)) {
            data["entries"] = [];
            for (let item of this.entries)
                data["entries"].push(item.toJSON());
        }
        super.toJSON(data);
        return data;
    }
}

export interface IRandomEffectView extends IEffectView {
    entries: RandomEffectEntryView[];
}

export class RandomEffectEntryView implements IRandomEffectEntryView {
    effect!: EffectView;
    probability!: number;

    constructor(data?: IRandomEffectEntryView) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.effect = _data["effect"] ? EffectView.fromJS(_data["effect"]) : <any>undefined;
            this.probability = _data["probability"];
        }
    }

    static fromJS(data: any): RandomEffectEntryView {
        data = typeof data === 'object' ? data : {};
        let result = new RandomEffectEntryView();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["effect"] = this.effect ? this.effect.toJSON() : <any>undefined;
        data["probability"] = this.probability;
        return data;
    }
}

export interface IRandomEffectEntryView {
    effect: EffectView;
    probability: number;
}

export class CombatInPreparationView implements ICombatInPreparationView {
    id!: string;
    randomSeed?: string | undefined;
    leftPlayerName!: string;
    leftFrontCharacter?: string | undefined;
    leftBackCharacter?: string | undefined;
    leftReady!: boolean;
    rightPlayerIsAi!: boolean;
    rightPlayerName?: string | undefined;
    rightFrontCharacter?: string | undefined;
    rightBackCharacter?: string | undefined;
    rightReady!: boolean;

    constructor(data?: ICombatInPreparationView) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.randomSeed = _data["randomSeed"];
            this.leftPlayerName = _data["leftPlayerName"];
            this.leftFrontCharacter = _data["leftFrontCharacter"];
            this.leftBackCharacter = _data["leftBackCharacter"];
            this.leftReady = _data["leftReady"];
            this.rightPlayerIsAi = _data["rightPlayerIsAi"];
            this.rightPlayerName = _data["rightPlayerName"];
            this.rightFrontCharacter = _data["rightFrontCharacter"];
            this.rightBackCharacter = _data["rightBackCharacter"];
            this.rightReady = _data["rightReady"];
        }
    }

    static fromJS(data: any): CombatInPreparationView {
        data = typeof data === 'object' ? data : {};
        let result = new CombatInPreparationView();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["randomSeed"] = this.randomSeed;
        data["leftPlayerName"] = this.leftPlayerName;
        data["leftFrontCharacter"] = this.leftFrontCharacter;
        data["leftBackCharacter"] = this.leftBackCharacter;
        data["leftReady"] = this.leftReady;
        data["rightPlayerIsAi"] = this.rightPlayerIsAi;
        data["rightPlayerName"] = this.rightPlayerName;
        data["rightFrontCharacter"] = this.rightFrontCharacter;
        data["rightBackCharacter"] = this.rightBackCharacter;
        data["rightReady"] = this.rightReady;
        return data;
    }
}

export interface ICombatInPreparationView {
    id: string;
    randomSeed?: string | undefined;
    leftPlayerName: string;
    leftFrontCharacter?: string | undefined;
    leftBackCharacter?: string | undefined;
    leftReady: boolean;
    rightPlayerIsAi: boolean;
    rightPlayerName?: string | undefined;
    rightFrontCharacter?: string | undefined;
    rightBackCharacter?: string | undefined;
    rightReady: boolean;
}

export class UpdateCombatInPreparationRequest implements IUpdateCombatInPreparationRequest {
    playerName!: string;
    randomSeed?: string | undefined;

    constructor(data?: IUpdateCombatInPreparationRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.playerName = _data["playerName"];
            this.randomSeed = _data["randomSeed"];
        }
    }

    static fromJS(data: any): UpdateCombatInPreparationRequest {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateCombatInPreparationRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["playerName"] = this.playerName;
        data["randomSeed"] = this.randomSeed;
        return data;
    }
}

export interface IUpdateCombatInPreparationRequest {
    playerName: string;
    randomSeed?: string | undefined;
}

export class UpdateCombatInPreparationSideRequest implements IUpdateCombatInPreparationSideRequest {
    isAi?: boolean | undefined;
    playerName!: string;
    ready!: boolean;
    frontCharacter?: string | undefined;
    backCharacter?: string | undefined;

    constructor(data?: IUpdateCombatInPreparationSideRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.isAi = _data["isAi"];
            this.playerName = _data["playerName"];
            this.ready = _data["ready"];
            this.frontCharacter = _data["frontCharacter"];
            this.backCharacter = _data["backCharacter"];
        }
    }

    static fromJS(data: any): UpdateCombatInPreparationSideRequest {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateCombatInPreparationSideRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["isAi"] = this.isAi;
        data["playerName"] = this.playerName;
        data["ready"] = this.ready;
        data["frontCharacter"] = this.frontCharacter;
        data["backCharacter"] = this.backCharacter;
        return data;
    }
}

export interface IUpdateCombatInPreparationSideRequest {
    isAi?: boolean | undefined;
    playerName: string;
    ready: boolean;
    frontCharacter?: string | undefined;
    backCharacter?: string | undefined;
}

export class BaseCombatView implements IBaseCombatView {
    ongoing!: boolean;
    over!: boolean;
    turn!: number;
    maxAp!: number;
    currentSide!: CombatSide;
    currentPhase!: CombatSideTurnPhase;
    winner!: CombatSide;
    leftPlayerName!: string;
    rightPlayerName!: string;
    log!: CombatLogView;

    constructor(data?: IBaseCombatView) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.log = new CombatLogView();
        }
    }

    init(_data?: any) {
        if (_data) {
            this.ongoing = _data["ongoing"];
            this.over = _data["over"];
            this.turn = _data["turn"];
            this.maxAp = _data["maxAp"];
            this.currentSide = _data["currentSide"];
            this.currentPhase = _data["currentPhase"];
            this.winner = _data["winner"];
            this.leftPlayerName = _data["leftPlayerName"];
            this.rightPlayerName = _data["rightPlayerName"];
            this.log = _data["log"] ? CombatLogView.fromJS(_data["log"]) : new CombatLogView();
        }
    }

    static fromJS(data: any): BaseCombatView {
        data = typeof data === 'object' ? data : {};
        let result = new BaseCombatView();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["ongoing"] = this.ongoing;
        data["over"] = this.over;
        data["turn"] = this.turn;
        data["maxAp"] = this.maxAp;
        data["currentSide"] = this.currentSide;
        data["currentPhase"] = this.currentPhase;
        data["winner"] = this.winner;
        data["leftPlayerName"] = this.leftPlayerName;
        data["rightPlayerName"] = this.rightPlayerName;
        data["log"] = this.log ? this.log.toJSON() : <any>undefined;
        return data;
    }
}

export interface IBaseCombatView {
    ongoing: boolean;
    over: boolean;
    turn: number;
    maxAp: number;
    currentSide: CombatSide;
    currentPhase: CombatSideTurnPhase;
    winner: CombatSide;
    leftPlayerName: string;
    rightPlayerName: string;
    log: CombatLogView;
}

export class PlayerCombatView extends BaseCombatView implements IPlayerCombatView {
    id!: string;
    player!: PlayerSideView;
    playerIsAi!: boolean;
    opponent!: CombatSideView;
    opponentIsAi!: boolean;

    constructor(data?: IPlayerCombatView) {
        super(data);
        if (!data) {
            this.player = new PlayerSideView();
            this.opponent = new CombatSideView();
        }
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.id = _data["id"];
            this.player = _data["player"] ? PlayerSideView.fromJS(_data["player"]) : new PlayerSideView();
            this.playerIsAi = _data["playerIsAi"];
            this.opponent = _data["opponent"] ? CombatSideView.fromJS(_data["opponent"]) : new CombatSideView();
            this.opponentIsAi = _data["opponentIsAi"];
        }
    }

    static override fromJS(data: any): PlayerCombatView {
        data = typeof data === 'object' ? data : {};
        let result = new PlayerCombatView();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["player"] = this.player ? this.player.toJSON() : <any>undefined;
        data["playerIsAi"] = this.playerIsAi;
        data["opponent"] = this.opponent ? this.opponent.toJSON() : <any>undefined;
        data["opponentIsAi"] = this.opponentIsAi;
        super.toJSON(data);
        return data;
    }
}

export interface IPlayerCombatView extends IBaseCombatView {
    id: string;
    player: PlayerSideView;
    playerIsAi: boolean;
    opponent: CombatSideView;
    opponentIsAi: boolean;
}

export class CombatSideView implements ICombatSideView {
    playerName!: string;
    side!: CombatSide;
    ap!: number;
    handSize!: number;
    deckSize!: number;
    frontCharacter?: CharacterCombatView | undefined;
    backCharacter?: CharacterCombatView | undefined;
    deadCharacters!: CharacterCombatView[];

    constructor(data?: ICombatSideView) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.deadCharacters = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            this.playerName = _data["playerName"];
            this.side = _data["side"];
            this.ap = _data["ap"];
            this.handSize = _data["handSize"];
            this.deckSize = _data["deckSize"];
            this.frontCharacter = _data["frontCharacter"] ? CharacterCombatView.fromJS(_data["frontCharacter"]) : <any>undefined;
            this.backCharacter = _data["backCharacter"] ? CharacterCombatView.fromJS(_data["backCharacter"]) : <any>undefined;
            if (Array.isArray(_data["deadCharacters"])) {
                this.deadCharacters = [] as any;
                for (let item of _data["deadCharacters"])
                    this.deadCharacters!.push(CharacterCombatView.fromJS(item));
            }
        }
    }

    static fromJS(data: any): CombatSideView {
        data = typeof data === 'object' ? data : {};
        let result = new CombatSideView();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["playerName"] = this.playerName;
        data["side"] = this.side;
        data["ap"] = this.ap;
        data["handSize"] = this.handSize;
        data["deckSize"] = this.deckSize;
        data["frontCharacter"] = this.frontCharacter ? this.frontCharacter.toJSON() : <any>undefined;
        data["backCharacter"] = this.backCharacter ? this.backCharacter.toJSON() : <any>undefined;
        if (Array.isArray(this.deadCharacters)) {
            data["deadCharacters"] = [];
            for (let item of this.deadCharacters)
                data["deadCharacters"].push(item.toJSON());
        }
        return data;
    }
}

export interface ICombatSideView {
    playerName: string;
    side: CombatSide;
    ap: number;
    handSize: number;
    deckSize: number;
    frontCharacter?: CharacterCombatView | undefined;
    backCharacter?: CharacterCombatView | undefined;
    deadCharacters: CharacterCombatView[];
}

export class PlayerSideView extends CombatSideView implements IPlayerSideView {
    hand!: CardInstanceWithModificationsView[];

    constructor(data?: IPlayerSideView) {
        super(data);
        if (!data) {
            this.hand = [];
        }
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            if (Array.isArray(_data["hand"])) {
                this.hand = [] as any;
                for (let item of _data["hand"])
                    this.hand!.push(CardInstanceWithModificationsView.fromJS(item));
            }
        }
    }

    static override fromJS(data: any): PlayerSideView {
        data = typeof data === 'object' ? data : {};
        let result = new PlayerSideView();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.hand)) {
            data["hand"] = [];
            for (let item of this.hand)
                data["hand"].push(item.toJSON());
        }
        super.toJSON(data);
        return data;
    }
}

export interface IPlayerSideView extends ICombatSideView {
    hand: CardInstanceWithModificationsView[];
}

export class CardInstanceView implements ICardInstanceView {
    card!: ActionCardView;
    character!: string;

    constructor(data?: ICardInstanceView) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.card = new ActionCardView();
        }
    }

    init(_data?: any) {
        if (_data) {
            this.card = _data["card"] ? ActionCardView.fromJS(_data["card"]) : new ActionCardView();
            this.character = _data["character"];
        }
    }

    static fromJS(data: any): CardInstanceView {
        data = typeof data === 'object' ? data : {};
        let result = new CardInstanceView();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["card"] = this.card ? this.card.toJSON() : <any>undefined;
        data["character"] = this.character;
        return data;
    }
}

export interface ICardInstanceView {
    card: ActionCardView;
    character: string;
}

export class CardInstanceWithModificationsView extends CardInstanceView implements ICardInstanceWithModificationsView {
    baseCard!: ActionCardView;

    constructor(data?: ICardInstanceWithModificationsView) {
        super(data);
        if (!data) {
            this.baseCard = new ActionCardView();
        }
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.baseCard = _data["baseCard"] ? ActionCardView.fromJS(_data["baseCard"]) : new ActionCardView();
        }
    }

    static override fromJS(data: any): CardInstanceWithModificationsView {
        data = typeof data === 'object' ? data : {};
        let result = new CardInstanceWithModificationsView();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["baseCard"] = this.baseCard ? this.baseCard.toJSON() : <any>undefined;
        super.toJSON(data);
        return data;
    }
}

export interface ICardInstanceWithModificationsView extends ICardInstanceView {
    baseCard: ActionCardView;
}

export enum CombatSide {
    None = "none",
    Left = "left",
    Right = "right",
}

export class CharacterCombatView implements ICharacterCombatView {
    character!: CharacterView;
    health!: number;
    shield!: number;
    isDead!: boolean;
    enchantments!: EnchantmentInstanceView[];

    constructor(data?: ICharacterCombatView) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.character = new CharacterView();
            this.enchantments = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            this.character = _data["character"] ? CharacterView.fromJS(_data["character"]) : new CharacterView();
            this.health = _data["health"];
            this.shield = _data["shield"];
            this.isDead = _data["isDead"];
            if (Array.isArray(_data["enchantments"])) {
                this.enchantments = [] as any;
                for (let item of _data["enchantments"])
                    this.enchantments!.push(EnchantmentInstanceView.fromJS(item));
            }
        }
    }

    static fromJS(data: any): CharacterCombatView {
        data = typeof data === 'object' ? data : {};
        let result = new CharacterCombatView();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["character"] = this.character ? this.character.toJSON() : <any>undefined;
        data["health"] = this.health;
        data["shield"] = this.shield;
        data["isDead"] = this.isDead;
        if (Array.isArray(this.enchantments)) {
            data["enchantments"] = [];
            for (let item of this.enchantments)
                data["enchantments"].push(item.toJSON());
        }
        return data;
    }
}

export interface ICharacterCombatView {
    character: CharacterView;
    health: number;
    shield: number;
    isDead: boolean;
    enchantments: EnchantmentInstanceView[];
}

export class EnchantmentInstanceView implements IEnchantmentInstanceView {
    id!: string;
    enchantment!: EnchantmentView;
    source!: CharacterInCombatView;
    target!: CharacterInCombatView;
    passive!: PassiveEffectInstanceView[];
    triggered!: TriggeredEffectInstanceView[];

    constructor(data?: IEnchantmentInstanceView) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.enchantment = new EnchantmentView();
            this.source = new CharacterInCombatView();
            this.target = new CharacterInCombatView();
            this.passive = [];
            this.triggered = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.enchantment = _data["enchantment"] ? EnchantmentView.fromJS(_data["enchantment"]) : new EnchantmentView();
            this.source = _data["source"] ? CharacterInCombatView.fromJS(_data["source"]) : new CharacterInCombatView();
            this.target = _data["target"] ? CharacterInCombatView.fromJS(_data["target"]) : new CharacterInCombatView();
            if (Array.isArray(_data["passive"])) {
                this.passive = [] as any;
                for (let item of _data["passive"])
                    this.passive!.push(PassiveEffectInstanceView.fromJS(item));
            }
            if (Array.isArray(_data["triggered"])) {
                this.triggered = [] as any;
                for (let item of _data["triggered"])
                    this.triggered!.push(TriggeredEffectInstanceView.fromJS(item));
            }
        }
    }

    static fromJS(data: any): EnchantmentInstanceView {
        data = typeof data === 'object' ? data : {};
        let result = new EnchantmentInstanceView();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["enchantment"] = this.enchantment ? this.enchantment.toJSON() : <any>undefined;
        data["source"] = this.source ? this.source.toJSON() : <any>undefined;
        data["target"] = this.target ? this.target.toJSON() : <any>undefined;
        if (Array.isArray(this.passive)) {
            data["passive"] = [];
            for (let item of this.passive)
                data["passive"].push(item.toJSON());
        }
        if (Array.isArray(this.triggered)) {
            data["triggered"] = [];
            for (let item of this.triggered)
                data["triggered"].push(item.toJSON());
        }
        return data;
    }
}

export interface IEnchantmentInstanceView {
    id: string;
    enchantment: EnchantmentView;
    source: CharacterInCombatView;
    target: CharacterInCombatView;
    passive: PassiveEffectInstanceView[];
    triggered: TriggeredEffectInstanceView[];
}

export class CharacterInCombatView implements ICharacterInCombatView {
    name!: string;
    side!: CombatSide;

    constructor(data?: ICharacterInCombatView) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.side = _data["side"];
        }
    }

    static fromJS(data: any): CharacterInCombatView {
        data = typeof data === 'object' ? data : {};
        let result = new CharacterInCombatView();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["side"] = this.side;
        return data;
    }
}

export interface ICharacterInCombatView {
    name: string;
    side: CombatSide;
}

export class PassiveEffectInstanceView implements IPassiveEffectInstanceView {
    id!: string;
    effect!: PassiveEffectView;
    source!: CharacterInCombatView;
    remainingDuration!: number;

    constructor(data?: IPassiveEffectInstanceView) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.effect = new PassiveEffectView();
            this.source = new CharacterInCombatView();
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.effect = _data["effect"] ? PassiveEffectView.fromJS(_data["effect"]) : new PassiveEffectView();
            this.source = _data["source"] ? CharacterInCombatView.fromJS(_data["source"]) : new CharacterInCombatView();
            this.remainingDuration = _data["remainingDuration"];
        }
    }

    static fromJS(data: any): PassiveEffectInstanceView {
        data = typeof data === 'object' ? data : {};
        let result = new PassiveEffectInstanceView();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["effect"] = this.effect ? this.effect.toJSON() : <any>undefined;
        data["source"] = this.source ? this.source.toJSON() : <any>undefined;
        data["remainingDuration"] = this.remainingDuration;
        return data;
    }
}

export interface IPassiveEffectInstanceView {
    id: string;
    effect: PassiveEffectView;
    source: CharacterInCombatView;
    remainingDuration: number;
}

export class TriggeredEffectInstanceView implements ITriggeredEffectInstanceView {
    id!: string;
    effect!: TriggeredEffectView;
    source!: CharacterInCombatView;
    triggerState!: TriggerStateView;

    constructor(data?: ITriggeredEffectInstanceView) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.effect = new TriggeredEffectView();
            this.source = new CharacterInCombatView();
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.effect = _data["effect"] ? TriggeredEffectView.fromJS(_data["effect"]) : new TriggeredEffectView();
            this.source = _data["source"] ? CharacterInCombatView.fromJS(_data["source"]) : new CharacterInCombatView();
            this.triggerState = _data["triggerState"] ? TriggerStateView.fromJS(_data["triggerState"]) : <any>undefined;
        }
    }

    static fromJS(data: any): TriggeredEffectInstanceView {
        data = typeof data === 'object' ? data : {};
        let result = new TriggeredEffectInstanceView();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["effect"] = this.effect ? this.effect.toJSON() : <any>undefined;
        data["source"] = this.source ? this.source.toJSON() : <any>undefined;
        data["triggerState"] = this.triggerState ? this.triggerState.toJSON() : <any>undefined;
        return data;
    }
}

export interface ITriggeredEffectInstanceView {
    id: string;
    effect: TriggeredEffectView;
    source: CharacterInCombatView;
    triggerState: TriggerStateView;
}

export abstract class TriggerStateView implements ITriggerStateView {

    protected _discriminator: string;

    constructor(data?: ITriggerStateView) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        this._discriminator = "TriggerStateView";
    }

    init(_data?: any) {
    }

    static fromJS(data: any): TriggerStateView {
        data = typeof data === 'object' ? data : {};
        if (data["triggerType"] === "TurnTriggerStateView") {
            let result = new TurnTriggerStateView();
            result.init(data);
            return result;
        }
        throw new Error("The abstract class 'TriggerStateView' cannot be instantiated.");
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["triggerType"] = this._discriminator;
        return data;
    }
}

export interface ITriggerStateView {
}

export class TurnTriggerStateView extends TriggerStateView implements ITurnTriggerStateView {
    triggersIn!: number;
    remainingDuration!: number;

    constructor(data?: ITurnTriggerStateView) {
        super(data);
        this._discriminator = "TurnTriggerStateView";
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.triggersIn = _data["triggersIn"];
            this.remainingDuration = _data["remainingDuration"];
        }
    }

    static override fromJS(data: any): TurnTriggerStateView {
        data = typeof data === 'object' ? data : {};
        let result = new TurnTriggerStateView();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["triggersIn"] = this.triggersIn;
        data["remainingDuration"] = this.remainingDuration;
        super.toJSON(data);
        return data;
    }
}

export interface ITurnTriggerStateView extends ITriggerStateView {
    triggersIn: number;
    remainingDuration: number;
}

export enum CombatSideTurnPhase {
    None = "none",
    StartOfTurn = "startOfTurn",
    Draw = "draw",
    Play = "play",
    EndOfTurn = "endOfTurn",
}

export class CombatLogView implements ICombatLogView {
    entries!: CombatLogEntryView[];

    constructor(data?: ICombatLogView) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.entries = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["entries"])) {
                this.entries = [] as any;
                for (let item of _data["entries"])
                    this.entries!.push(CombatLogEntryView.fromJS(item));
            }
        }
    }

    static fromJS(data: any): CombatLogView {
        data = typeof data === 'object' ? data : {};
        let result = new CombatLogView();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.entries)) {
            data["entries"] = [];
            for (let item of this.entries)
                data["entries"].push(item.toJSON());
        }
        return data;
    }
}

export interface ICombatLogView {
    entries: CombatLogEntryView[];
}

export abstract class CombatLogEntryView implements ICombatLogEntryView {

    protected _discriminator: string;

    constructor(data?: ICombatLogEntryView) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        this._discriminator = "CombatLogEntryView";
    }

    init(_data?: any) {
    }

    static fromJS(data: any): CombatLogEntryView {
        data = typeof data === 'object' ? data : {};
        if (data["entryType"] === "TurnStartedLogEntryView") {
            let result = new TurnStartedLogEntryView();
            result.init(data);
            return result;
        }
        if (data["entryType"] === "CardPlayedLogEntryView") {
            let result = new CardPlayedLogEntryView();
            result.init(data);
            return result;
        }
        if (data["entryType"] === "CombatEndedLogEntryView") {
            let result = new CombatEndedLogEntryView();
            result.init(data);
            return result;
        }
        throw new Error("The abstract class 'CombatLogEntryView' cannot be instantiated.");
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["entryType"] = this._discriminator;
        return data;
    }
}

export interface ICombatLogEntryView {
}

export class TurnStartedLogEntryView extends CombatLogEntryView implements ITurnStartedLogEntryView {
    turn!: number;

    constructor(data?: ITurnStartedLogEntryView) {
        super(data);
        this._discriminator = "TurnStartedLogEntryView";
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.turn = _data["turn"];
        }
    }

    static override fromJS(data: any): TurnStartedLogEntryView {
        data = typeof data === 'object' ? data : {};
        let result = new TurnStartedLogEntryView();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["turn"] = this.turn;
        super.toJSON(data);
        return data;
    }
}

export interface ITurnStartedLogEntryView extends ICombatLogEntryView {
    turn: number;
}

export class CardPlayedLogEntryView extends CombatLogEntryView implements ICardPlayedLogEntryView {
    source!: CharacterInCombatView;
    card!: ActionCardView;
    effects!: EffectOnCharacterLogEntryView[];

    constructor(data?: ICardPlayedLogEntryView) {
        super(data);
        if (!data) {
            this.source = new CharacterInCombatView();
            this.card = new ActionCardView();
            this.effects = [];
        }
        this._discriminator = "CardPlayedLogEntryView";
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.source = _data["source"] ? CharacterInCombatView.fromJS(_data["source"]) : new CharacterInCombatView();
            this.card = _data["card"] ? ActionCardView.fromJS(_data["card"]) : new ActionCardView();
            if (Array.isArray(_data["effects"])) {
                this.effects = [] as any;
                for (let item of _data["effects"])
                    this.effects!.push(EffectOnCharacterLogEntryView.fromJS(item));
            }
        }
    }

    static override fromJS(data: any): CardPlayedLogEntryView {
        data = typeof data === 'object' ? data : {};
        let result = new CardPlayedLogEntryView();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["source"] = this.source ? this.source.toJSON() : <any>undefined;
        data["card"] = this.card ? this.card.toJSON() : <any>undefined;
        if (Array.isArray(this.effects)) {
            data["effects"] = [];
            for (let item of this.effects)
                data["effects"].push(item.toJSON());
        }
        super.toJSON(data);
        return data;
    }
}

export interface ICardPlayedLogEntryView extends ICombatLogEntryView {
    source: CharacterInCombatView;
    card: ActionCardView;
    effects: EffectOnCharacterLogEntryView[];
}

export abstract class EffectOnCharacterLogEntryView implements IEffectOnCharacterLogEntryView {
    character!: CharacterInCombatView;

    protected _discriminator: string;

    constructor(data?: IEffectOnCharacterLogEntryView) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.character = new CharacterInCombatView();
        }
        this._discriminator = "EffectOnCharacterLogEntryView";
    }

    init(_data?: any) {
        if (_data) {
            this.character = _data["character"] ? CharacterInCombatView.fromJS(_data["character"]) : new CharacterInCombatView();
        }
    }

    static fromJS(data: any): EffectOnCharacterLogEntryView {
        data = typeof data === 'object' ? data : {};
        if (data["effectType"] === "DamageEffectOnCharacterLogEntryView") {
            let result = new DamageEffectOnCharacterLogEntryView();
            result.init(data);
            return result;
        }
        if (data["effectType"] === "HealEffectOnCharacterLogEntryView") {
            let result = new HealEffectOnCharacterLogEntryView();
            result.init(data);
            return result;
        }
        if (data["effectType"] === "ShieldEffectOnCharacterLogEntryView") {
            let result = new ShieldEffectOnCharacterLogEntryView();
            result.init(data);
            return result;
        }
        if (data["effectType"] === "AddEnchantmentEffectOnCharacterLogEntryView") {
            let result = new AddEnchantmentEffectOnCharacterLogEntryView();
            result.init(data);
            return result;
        }
        if (data["effectType"] === "CharacterDiedLogEntryView") {
            let result = new CharacterDiedLogEntryView();
            result.init(data);
            return result;
        }
        throw new Error("The abstract class 'EffectOnCharacterLogEntryView' cannot be instantiated.");
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["effectType"] = this._discriminator;
        data["character"] = this.character ? this.character.toJSON() : <any>undefined;
        return data;
    }
}

export interface IEffectOnCharacterLogEntryView {
    character: CharacterInCombatView;
}

export class DamageEffectOnCharacterLogEntryView extends EffectOnCharacterLogEntryView implements IDamageEffectOnCharacterLogEntryView {
    damage!: DamageReceived;

    constructor(data?: IDamageEffectOnCharacterLogEntryView) {
        super(data);
        if (!data) {
            this.damage = new DamageReceived();
        }
        this._discriminator = "DamageEffectOnCharacterLogEntryView";
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.damage = _data["damage"] ? DamageReceived.fromJS(_data["damage"]) : new DamageReceived();
        }
    }

    static override fromJS(data: any): DamageEffectOnCharacterLogEntryView {
        data = typeof data === 'object' ? data : {};
        let result = new DamageEffectOnCharacterLogEntryView();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["damage"] = this.damage ? this.damage.toJSON() : <any>undefined;
        super.toJSON(data);
        return data;
    }
}

export interface IDamageEffectOnCharacterLogEntryView extends IEffectOnCharacterLogEntryView {
    damage: DamageReceived;
}

export class DamageReceived implements IDamageReceived {
    health!: number;
    shield!: number;

    constructor(data?: IDamageReceived) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.health = _data["health"];
            this.shield = _data["shield"];
        }
    }

    static fromJS(data: any): DamageReceived {
        data = typeof data === 'object' ? data : {};
        let result = new DamageReceived();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["health"] = this.health;
        data["shield"] = this.shield;
        return data;
    }
}

export interface IDamageReceived {
    health: number;
    shield: number;
}

export class HealEffectOnCharacterLogEntryView extends EffectOnCharacterLogEntryView implements IHealEffectOnCharacterLogEntryView {
    heal!: HealReceived;

    constructor(data?: IHealEffectOnCharacterLogEntryView) {
        super(data);
        if (!data) {
            this.heal = new HealReceived();
        }
        this._discriminator = "HealEffectOnCharacterLogEntryView";
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.heal = _data["heal"] ? HealReceived.fromJS(_data["heal"]) : new HealReceived();
        }
    }

    static override fromJS(data: any): HealEffectOnCharacterLogEntryView {
        data = typeof data === 'object' ? data : {};
        let result = new HealEffectOnCharacterLogEntryView();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["heal"] = this.heal ? this.heal.toJSON() : <any>undefined;
        super.toJSON(data);
        return data;
    }
}

export interface IHealEffectOnCharacterLogEntryView extends IEffectOnCharacterLogEntryView {
    heal: HealReceived;
}

export class HealReceived implements IHealReceived {
    health!: number;

    constructor(data?: IHealReceived) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.health = _data["health"];
        }
    }

    static fromJS(data: any): HealReceived {
        data = typeof data === 'object' ? data : {};
        let result = new HealReceived();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["health"] = this.health;
        return data;
    }
}

export interface IHealReceived {
    health: number;
}

export class ShieldEffectOnCharacterLogEntryView extends EffectOnCharacterLogEntryView implements IShieldEffectOnCharacterLogEntryView {
    shield!: ShieldReceived;

    constructor(data?: IShieldEffectOnCharacterLogEntryView) {
        super(data);
        if (!data) {
            this.shield = new ShieldReceived();
        }
        this._discriminator = "ShieldEffectOnCharacterLogEntryView";
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.shield = _data["shield"] ? ShieldReceived.fromJS(_data["shield"]) : new ShieldReceived();
        }
    }

    static override fromJS(data: any): ShieldEffectOnCharacterLogEntryView {
        data = typeof data === 'object' ? data : {};
        let result = new ShieldEffectOnCharacterLogEntryView();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["shield"] = this.shield ? this.shield.toJSON() : <any>undefined;
        super.toJSON(data);
        return data;
    }
}

export interface IShieldEffectOnCharacterLogEntryView extends IEffectOnCharacterLogEntryView {
    shield: ShieldReceived;
}

export class ShieldReceived implements IShieldReceived {
    shield!: number;

    constructor(data?: IShieldReceived) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.shield = _data["shield"];
        }
    }

    static fromJS(data: any): ShieldReceived {
        data = typeof data === 'object' ? data : {};
        let result = new ShieldReceived();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["shield"] = this.shield;
        return data;
    }
}

export interface IShieldReceived {
    shield: number;
}

export class AddEnchantmentEffectOnCharacterLogEntryView extends EffectOnCharacterLogEntryView implements IAddEnchantmentEffectOnCharacterLogEntryView {
    enchantment!: EnchantmentView;

    constructor(data?: IAddEnchantmentEffectOnCharacterLogEntryView) {
        super(data);
        if (!data) {
            this.enchantment = new EnchantmentView();
        }
        this._discriminator = "AddEnchantmentEffectOnCharacterLogEntryView";
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.enchantment = _data["enchantment"] ? EnchantmentView.fromJS(_data["enchantment"]) : new EnchantmentView();
        }
    }

    static override fromJS(data: any): AddEnchantmentEffectOnCharacterLogEntryView {
        data = typeof data === 'object' ? data : {};
        let result = new AddEnchantmentEffectOnCharacterLogEntryView();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["enchantment"] = this.enchantment ? this.enchantment.toJSON() : <any>undefined;
        super.toJSON(data);
        return data;
    }
}

export interface IAddEnchantmentEffectOnCharacterLogEntryView extends IEffectOnCharacterLogEntryView {
    enchantment: EnchantmentView;
}

export class CharacterDiedLogEntryView extends EffectOnCharacterLogEntryView implements ICharacterDiedLogEntryView {

    constructor(data?: ICharacterDiedLogEntryView) {
        super(data);
        this._discriminator = "CharacterDiedLogEntryView";
    }

    override init(_data?: any) {
        super.init(_data);
    }

    static override fromJS(data: any): CharacterDiedLogEntryView {
        data = typeof data === 'object' ? data : {};
        let result = new CharacterDiedLogEntryView();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export interface ICharacterDiedLogEntryView extends IEffectOnCharacterLogEntryView {
}

export class CombatEndedLogEntryView extends CombatLogEntryView implements ICombatEndedLogEntryView {
    winner!: CombatSide;

    constructor(data?: ICombatEndedLogEntryView) {
        super(data);
        this._discriminator = "CombatEndedLogEntryView";
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.winner = _data["winner"];
        }
    }

    static override fromJS(data: any): CombatEndedLogEntryView {
        data = typeof data === 'object' ? data : {};
        let result = new CombatEndedLogEntryView();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["winner"] = this.winner;
        super.toJSON(data);
        return data;
    }
}

export interface ICombatEndedLogEntryView extends ICombatLogEntryView {
    winner: CombatSide;
}

export interface FileResponse {
    data: Blob;
    status: number;
    fileName?: string;
    headers?: { [name: string]: any };
}

export class ApiException extends Error {
    override message: string;
    status: number;
    response: string;
    headers: { [key: string]: any; };
    result: any;

    constructor(message: string, status: number, response: string, headers: { [key: string]: any; }, result: any) {
        super();

        this.message = message;
        this.status = status;
        this.response = response;
        this.headers = headers;
        this.result = result;
    }

    protected isApiException = true;

    static isApiException(obj: any): obj is ApiException {
        return obj.isApiException === true;
    }
}

function throwException(message: string, status: number, response: string, headers: { [key: string]: any; }, result?: any): Observable<any> {
    if (result !== null && result !== undefined)
        return _observableThrow(result);
    else
        return _observableThrow(new ApiException(message, status, response, headers, null));
}

function blobToText(blob: any): Observable<string> {
    return new Observable<string>((observer: any) => {
        if (!blob) {
            observer.next("");
            observer.complete();
        } else {
            let reader = new FileReader();
            reader.onload = event => {
                observer.next((event.target as any).result);
                observer.complete();
            };
            reader.readAsText(blob);
        }
    });
}