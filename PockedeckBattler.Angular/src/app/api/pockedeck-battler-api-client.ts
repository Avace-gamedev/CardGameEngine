//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v13.18.2.0 (NJsonSchema v10.8.0.0 (Newtonsoft.Json v11.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------

/* tslint:disable */
/* eslint-disable */
// ReSharper disable InconsistentNaming

import { mergeMap as _observableMergeMap, catchError as _observableCatch } from 'rxjs/operators';
import { Observable, throwError as _observableThrow, of as _observableOf } from 'rxjs';
import { Injectable, Inject, Optional, InjectionToken } from '@angular/core';
import { HttpClient, HttpHeaders, HttpResponse, HttpResponseBase } from '@angular/common/http';

import * as moment from 'moment';

export const API_BASE_URL = new InjectionToken<string>('API_BASE_URL');

export interface ICharactersService {
    getAll(): Observable<CharacterView[]>;
    get(name: string): Observable<CharacterView>;
}

@Injectable({
    providedIn: 'root'
})
export class CharactersService implements ICharactersService {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "http://localhost:5295";
    }

    getAll(): Observable<CharacterView[]> {
        let url_ = this.baseUrl + "/characters";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CharacterView[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CharacterView[]>;
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<CharacterView[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(CharacterView.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    get(name: string): Observable<CharacterView> {
        let url_ = this.baseUrl + "/characters/{name}";
        if (name === undefined || name === null)
            throw new Error("The parameter 'name' must be defined.");
        url_ = url_.replace("{name}", encodeURIComponent("" + name));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CharacterView>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CharacterView>;
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<CharacterView> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CharacterView.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

export interface ICombatsService {
    getAll(): Observable<string[]>;
    createCombat(request: CreateCombatRequest): Observable<PlayerCombatView>;
    get(id: string): Observable<CombatView>;
    getPlayerView(id: string, side: CombatSide): Observable<PlayerCombatView>;
    playCard(id: string, side: CombatSide, index: number): Observable<void>;
    endTurn(id: string, side: CombatSide): Observable<void>;
}

@Injectable({
    providedIn: 'root'
})
export class CombatsService implements ICombatsService {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "http://localhost:5295";
    }

    getAll(): Observable<string[]> {
        let url_ = this.baseUrl + "/combats";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<string[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<string[]>;
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<string[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(item);
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    createCombat(request: CreateCombatRequest): Observable<PlayerCombatView> {
        let url_ = this.baseUrl + "/combats";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateCombat(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateCombat(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PlayerCombatView>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PlayerCombatView>;
        }));
    }

    protected processCreateCombat(response: HttpResponseBase): Observable<PlayerCombatView> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PlayerCombatView.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    get(id: string): Observable<CombatView> {
        let url_ = this.baseUrl + "/combats/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CombatView>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CombatView>;
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<CombatView> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CombatView.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getPlayerView(id: string, side: CombatSide): Observable<PlayerCombatView> {
        let url_ = this.baseUrl + "/combats/{id}/{side}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (side === undefined || side === null)
            throw new Error("The parameter 'side' must be defined.");
        url_ = url_.replace("{side}", encodeURIComponent("" + side));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPlayerView(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPlayerView(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PlayerCombatView>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PlayerCombatView>;
        }));
    }

    protected processGetPlayerView(response: HttpResponseBase): Observable<PlayerCombatView> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PlayerCombatView.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    playCard(id: string, side: CombatSide, index: number): Observable<void> {
        let url_ = this.baseUrl + "/combats/{id}/{side}/play/{index}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (side === undefined || side === null)
            throw new Error("The parameter 'side' must be defined.");
        url_ = url_.replace("{side}", encodeURIComponent("" + side));
        if (index === undefined || index === null)
            throw new Error("The parameter 'index' must be defined.");
        url_ = url_.replace("{index}", encodeURIComponent("" + index));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPlayCard(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPlayCard(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processPlayCard(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    endTurn(id: string, side: CombatSide): Observable<void> {
        let url_ = this.baseUrl + "/combats/{id}/{side}/end-turn";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (side === undefined || side === null)
            throw new Error("The parameter 'side' must be defined.");
        url_ = url_.replace("{side}", encodeURIComponent("" + side));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processEndTurn(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processEndTurn(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processEndTurn(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

export class CharacterView implements ICharacterView {
    identity!: CharacterIdentity;
    statistics!: CharacterStatistics;
    deck!: ActionCardView[];

    constructor(data?: ICharacterView) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.identity = new CharacterIdentity();
            this.statistics = new CharacterStatistics();
            this.deck = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            this.identity = _data["identity"] ? CharacterIdentity.fromJS(_data["identity"]) : new CharacterIdentity();
            this.statistics = _data["statistics"] ? CharacterStatistics.fromJS(_data["statistics"]) : new CharacterStatistics();
            if (Array.isArray(_data["deck"])) {
                this.deck = [] as any;
                for (let item of _data["deck"])
                    this.deck!.push(ActionCardView.fromJS(item));
            }
        }
    }

    static fromJS(data: any): CharacterView {
        data = typeof data === 'object' ? data : {};
        let result = new CharacterView();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["identity"] = this.identity ? this.identity.toJSON() : <any>undefined;
        data["statistics"] = this.statistics ? this.statistics.toJSON() : <any>undefined;
        if (Array.isArray(this.deck)) {
            data["deck"] = [];
            for (let item of this.deck)
                data["deck"].push(item.toJSON());
        }
        return data;
    }
}

export interface ICharacterView {
    identity: CharacterIdentity;
    statistics: CharacterStatistics;
    deck: ActionCardView[];
}

export class CharacterIdentity implements ICharacterIdentity {
    name!: string;
    displayName!: string;
    description?: string | undefined;

    constructor(data?: ICharacterIdentity) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.displayName = _data["displayName"];
            this.description = _data["description"];
        }
    }

    static fromJS(data: any): CharacterIdentity {
        data = typeof data === 'object' ? data : {};
        let result = new CharacterIdentity();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["displayName"] = this.displayName;
        data["description"] = this.description;
        return data;
    }
}

export interface ICharacterIdentity {
    name: string;
    displayName: string;
    description?: string | undefined;
}

export class CharacterStatistics implements ICharacterStatistics {
    maxHealth!: number;

    constructor(data?: ICharacterStatistics) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.maxHealth = _data["maxHealth"];
        }
    }

    static fromJS(data: any): CharacterStatistics {
        data = typeof data === 'object' ? data : {};
        let result = new CharacterStatistics();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["maxHealth"] = this.maxHealth;
        return data;
    }
}

export interface ICharacterStatistics {
    maxHealth: number;
}

export class ActionCardView implements IActionCardView {
    name!: string;
    description?: string | undefined;
    apCost!: number;
    target!: ActionCardTarget;
    mainEffect!: ActiveEffectView;
    additionalEffects!: ActiveEffectView[];

    constructor(data?: IActionCardView) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.additionalEffects = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.description = _data["description"];
            this.apCost = _data["apCost"];
            this.target = _data["target"];
            this.mainEffect = _data["mainEffect"] ? ActiveEffectView.fromJS(_data["mainEffect"]) : <any>undefined;
            if (Array.isArray(_data["additionalEffects"])) {
                this.additionalEffects = [] as any;
                for (let item of _data["additionalEffects"])
                    this.additionalEffects!.push(ActiveEffectView.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ActionCardView {
        data = typeof data === 'object' ? data : {};
        let result = new ActionCardView();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["description"] = this.description;
        data["apCost"] = this.apCost;
        data["target"] = this.target;
        data["mainEffect"] = this.mainEffect ? this.mainEffect.toJSON() : <any>undefined;
        if (Array.isArray(this.additionalEffects)) {
            data["additionalEffects"] = [];
            for (let item of this.additionalEffects)
                data["additionalEffects"].push(item.toJSON());
        }
        return data;
    }
}

export interface IActionCardView {
    name: string;
    description?: string | undefined;
    apCost: number;
    target: ActionCardTarget;
    mainEffect: ActiveEffectView;
    additionalEffects: ActiveEffectView[];
}

export enum ActionCardTarget {
    None = "none",
    Self = "self",
    OtherAlly = "otherAlly",
    FrontOpponent = "frontOpponent",
    BackOpponent = "backOpponent",
    AllOpponents = "allOpponents",
    FrontAlly = "frontAlly",
    BackAlly = "backAlly",
    AllAllies = "allAllies",
}

export abstract class ActiveEffectView implements IActiveEffectView {

    protected _discriminator: string;

    constructor(data?: IActiveEffectView) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        this._discriminator = "ActiveEffectView";
    }

    init(_data?: any) {
    }

    static fromJS(data: any): ActiveEffectView {
        data = typeof data === 'object' ? data : {};
        if (data["type"] === "DamageEffectView") {
            let result = new DamageEffectView();
            result.init(data);
            return result;
        }
        if (data["type"] === "HealEffectView") {
            let result = new HealEffectView();
            result.init(data);
            return result;
        }
        if (data["type"] === "ShieldEffectView") {
            let result = new ShieldEffectView();
            result.init(data);
            return result;
        }
        if (data["type"] === "AddPassiveEffectView") {
            let result = new AddPassiveEffectView();
            result.init(data);
            return result;
        }
        if (data["type"] === "RandomEffectView") {
            let result = new RandomEffectView();
            result.init(data);
            return result;
        }
        throw new Error("The abstract class 'ActiveEffectView' cannot be instantiated.");
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["type"] = this._discriminator;
        return data;
    }
}

export interface IActiveEffectView {
}

export class DamageEffectView extends ActiveEffectView implements IDamageEffectView {
    amount!: number;
    element!: Element;

    constructor(data?: IDamageEffectView) {
        super(data);
        this._discriminator = "DamageEffectView";
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.amount = _data["amount"];
            this.element = _data["element"];
        }
    }

    static override fromJS(data: any): DamageEffectView {
        data = typeof data === 'object' ? data : {};
        let result = new DamageEffectView();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["amount"] = this.amount;
        data["element"] = this.element;
        super.toJSON(data);
        return data;
    }
}

export interface IDamageEffectView extends IActiveEffectView {
    amount: number;
    element: Element;
}

export enum Element {
    Neutral = "neutral",
    Fire = "fire",
    Earth = "earth",
    Water = "water",
    Wind = "wind",
}

export class HealEffectView extends ActiveEffectView implements IHealEffectView {
    amount!: number;

    constructor(data?: IHealEffectView) {
        super(data);
        this._discriminator = "HealEffectView";
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.amount = _data["amount"];
        }
    }

    static override fromJS(data: any): HealEffectView {
        data = typeof data === 'object' ? data : {};
        let result = new HealEffectView();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["amount"] = this.amount;
        super.toJSON(data);
        return data;
    }
}

export interface IHealEffectView extends IActiveEffectView {
    amount: number;
}

export class ShieldEffectView extends ActiveEffectView implements IShieldEffectView {
    amount!: number;

    constructor(data?: IShieldEffectView) {
        super(data);
        this._discriminator = "ShieldEffectView";
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.amount = _data["amount"];
        }
    }

    static override fromJS(data: any): ShieldEffectView {
        data = typeof data === 'object' ? data : {};
        let result = new ShieldEffectView();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["amount"] = this.amount;
        super.toJSON(data);
        return data;
    }
}

export interface IShieldEffectView extends IActiveEffectView {
    amount: number;
}

export class AddPassiveEffectView extends ActiveEffectView implements IAddPassiveEffectView {
    passiveEffect!: PassiveEffectView;

    constructor(data?: IAddPassiveEffectView) {
        super(data);
        if (!data) {
            this.passiveEffect = new PassiveEffectView();
        }
        this._discriminator = "AddPassiveEffectView";
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.passiveEffect = _data["passiveEffect"] ? PassiveEffectView.fromJS(_data["passiveEffect"]) : new PassiveEffectView();
        }
    }

    static override fromJS(data: any): AddPassiveEffectView {
        data = typeof data === 'object' ? data : {};
        let result = new AddPassiveEffectView();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["passiveEffect"] = this.passiveEffect ? this.passiveEffect.toJSON() : <any>undefined;
        super.toJSON(data);
        return data;
    }
}

export interface IAddPassiveEffectView extends IActiveEffectView {
    passiveEffect: PassiveEffectView;
}

export class PassiveEffectView implements IPassiveEffectView {
    duration!: number;

    protected _discriminator: string;

    constructor(data?: IPassiveEffectView) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        this._discriminator = "PassiveEffectView";
    }

    init(_data?: any) {
        if (_data) {
            this.duration = _data["duration"];
        }
    }

    static fromJS(data: any): PassiveEffectView {
        data = typeof data === 'object' ? data : {};
        if (data["type"] === "PassiveStatsModifierView") {
            let result = new PassiveStatsModifierView();
            result.init(data);
            return result;
        }
        if (data["type"] === "TriggeredEffectView") {
            let result = new TriggeredEffectView();
            result.init(data);
            return result;
        }
        let result = new PassiveEffectView();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["type"] = this._discriminator;
        data["duration"] = this.duration;
        return data;
    }
}

export interface IPassiveEffectView {
    duration: number;
}

export class PassiveStatsModifierView extends PassiveEffectView implements IPassiveStatsModifierView {
    statsModifier!: StatsModifier;

    constructor(data?: IPassiveStatsModifierView) {
        super(data);
        if (!data) {
            this.statsModifier = new StatsModifier();
        }
        this._discriminator = "PassiveStatsModifierView";
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.statsModifier = _data["statsModifier"] ? StatsModifier.fromJS(_data["statsModifier"]) : new StatsModifier();
        }
    }

    static override fromJS(data: any): PassiveStatsModifierView {
        data = typeof data === 'object' ? data : {};
        let result = new PassiveStatsModifierView();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["statsModifier"] = this.statsModifier ? this.statsModifier.toJSON() : <any>undefined;
        super.toJSON(data);
        return data;
    }
}

export interface IPassiveStatsModifierView extends IPassiveEffectView {
    statsModifier: StatsModifier;
}

export class StatsModifier implements IStatsModifier {
    healthAdditiveModifier!: number;
    apCostAdditiveModifier!: number;
    damageAdditiveModifier!: number;
    damageReductionAdditiveModifier!: number;

    constructor(data?: IStatsModifier) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.healthAdditiveModifier = _data["healthAdditiveModifier"];
            this.apCostAdditiveModifier = _data["apCostAdditiveModifier"];
            this.damageAdditiveModifier = _data["damageAdditiveModifier"];
            this.damageReductionAdditiveModifier = _data["damageReductionAdditiveModifier"];
        }
    }

    static fromJS(data: any): StatsModifier {
        data = typeof data === 'object' ? data : {};
        let result = new StatsModifier();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["healthAdditiveModifier"] = this.healthAdditiveModifier;
        data["apCostAdditiveModifier"] = this.apCostAdditiveModifier;
        data["damageAdditiveModifier"] = this.damageAdditiveModifier;
        data["damageReductionAdditiveModifier"] = this.damageReductionAdditiveModifier;
        return data;
    }
}

export interface IStatsModifier {
    healthAdditiveModifier: number;
    apCostAdditiveModifier: number;
    damageAdditiveModifier: number;
    damageReductionAdditiveModifier: number;
}

export class TriggeredEffectView extends PassiveEffectView implements ITriggeredEffectView {
    trigger!: EffectTriggerView;
    effect!: ActiveEffectView;

    constructor(data?: ITriggeredEffectView) {
        super(data);
        if (!data) {
            this.trigger = new EffectTriggerView();
        }
        this._discriminator = "TriggeredEffectView";
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.trigger = _data["trigger"] ? EffectTriggerView.fromJS(_data["trigger"]) : new EffectTriggerView();
            this.effect = _data["effect"] ? ActiveEffectView.fromJS(_data["effect"]) : <any>undefined;
        }
    }

    static override fromJS(data: any): TriggeredEffectView {
        data = typeof data === 'object' ? data : {};
        let result = new TriggeredEffectView();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["trigger"] = this.trigger ? this.trigger.toJSON() : <any>undefined;
        data["effect"] = this.effect ? this.effect.toJSON() : <any>undefined;
        super.toJSON(data);
        return data;
    }
}

export interface ITriggeredEffectView extends IPassiveEffectView {
    trigger: EffectTriggerView;
    effect: ActiveEffectView;
}

export class EffectTriggerView implements IEffectTriggerView {

    protected _discriminator: string;

    constructor(data?: IEffectTriggerView) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        this._discriminator = "EffectTriggerView";
    }

    init(_data?: any) {
    }

    static fromJS(data: any): EffectTriggerView {
        data = typeof data === 'object' ? data : {};
        if (data["type"] === "TurnTriggerView") {
            let result = new TurnTriggerView();
            result.init(data);
            return result;
        }
        let result = new EffectTriggerView();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["type"] = this._discriminator;
        return data;
    }
}

export interface IEffectTriggerView {
}

export class TurnTriggerView extends EffectTriggerView implements ITurnTriggerView {
    moment!: TurnMoment;

    constructor(data?: ITurnTriggerView) {
        super(data);
        this._discriminator = "TurnTriggerView";
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.moment = _data["moment"];
        }
    }

    static override fromJS(data: any): TurnTriggerView {
        data = typeof data === 'object' ? data : {};
        let result = new TurnTriggerView();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["moment"] = this.moment;
        super.toJSON(data);
        return data;
    }
}

export interface ITurnTriggerView extends IEffectTriggerView {
    moment: TurnMoment;
}

export enum TurnMoment {
    StartOfTurn = "startOfTurn",
    EndOfTurn = "endOfTurn",
}

export class RandomEffectView extends ActiveEffectView implements IRandomEffectView {
    entries!: RandomEffectEntryView[];

    constructor(data?: IRandomEffectView) {
        super(data);
        if (!data) {
            this.entries = [];
        }
        this._discriminator = "RandomEffectView";
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            if (Array.isArray(_data["entries"])) {
                this.entries = [] as any;
                for (let item of _data["entries"])
                    this.entries!.push(RandomEffectEntryView.fromJS(item));
            }
        }
    }

    static override fromJS(data: any): RandomEffectView {
        data = typeof data === 'object' ? data : {};
        let result = new RandomEffectView();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.entries)) {
            data["entries"] = [];
            for (let item of this.entries)
                data["entries"].push(item.toJSON());
        }
        super.toJSON(data);
        return data;
    }
}

export interface IRandomEffectView extends IActiveEffectView {
    entries: RandomEffectEntryView[];
}

export class RandomEffectEntryView implements IRandomEffectEntryView {
    effect!: ActiveEffectView;
    probability!: number;

    constructor(data?: IRandomEffectEntryView) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.effect = _data["effect"] ? ActiveEffectView.fromJS(_data["effect"]) : <any>undefined;
            this.probability = _data["probability"];
        }
    }

    static fromJS(data: any): RandomEffectEntryView {
        data = typeof data === 'object' ? data : {};
        let result = new RandomEffectEntryView();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["effect"] = this.effect ? this.effect.toJSON() : <any>undefined;
        data["probability"] = this.probability;
        return data;
    }
}

export interface IRandomEffectEntryView {
    effect: ActiveEffectView;
    probability: number;
}

export class BaseCombatView implements IBaseCombatView {
    ongoing!: boolean;
    over!: boolean;
    turn!: number;
    currentSide!: CombatSide;
    currentPhase!: CombatSideTurnPhase;

    constructor(data?: IBaseCombatView) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.ongoing = _data["ongoing"];
            this.over = _data["over"];
            this.turn = _data["turn"];
            this.currentSide = _data["currentSide"];
            this.currentPhase = _data["currentPhase"];
        }
    }

    static fromJS(data: any): BaseCombatView {
        data = typeof data === 'object' ? data : {};
        let result = new BaseCombatView();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["ongoing"] = this.ongoing;
        data["over"] = this.over;
        data["turn"] = this.turn;
        data["currentSide"] = this.currentSide;
        data["currentPhase"] = this.currentPhase;
        return data;
    }
}

export interface IBaseCombatView {
    ongoing: boolean;
    over: boolean;
    turn: number;
    currentSide: CombatSide;
    currentPhase: CombatSideTurnPhase;
}

export class CombatView extends BaseCombatView implements ICombatView {
    leftSide!: CombatSideView;
    rightSide!: CombatSideView;

    constructor(data?: ICombatView) {
        super(data);
        if (!data) {
            this.leftSide = new CombatSideView();
            this.rightSide = new CombatSideView();
        }
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.leftSide = _data["leftSide"] ? CombatSideView.fromJS(_data["leftSide"]) : new CombatSideView();
            this.rightSide = _data["rightSide"] ? CombatSideView.fromJS(_data["rightSide"]) : new CombatSideView();
        }
    }

    static override fromJS(data: any): CombatView {
        data = typeof data === 'object' ? data : {};
        let result = new CombatView();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["leftSide"] = this.leftSide ? this.leftSide.toJSON() : <any>undefined;
        data["rightSide"] = this.rightSide ? this.rightSide.toJSON() : <any>undefined;
        super.toJSON(data);
        return data;
    }
}

export interface ICombatView extends IBaseCombatView {
    leftSide: CombatSideView;
    rightSide: CombatSideView;
}

export abstract class BaseCombatSideView implements IBaseCombatSideView {
    side!: CombatSide;
    deckSize!: number;
    frontCharacter!: CharacterCombatView;
    backCharacter?: CharacterCombatView | undefined;

    constructor(data?: IBaseCombatSideView) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.frontCharacter = new CharacterCombatView();
        }
    }

    init(_data?: any) {
        if (_data) {
            this.side = _data["side"];
            this.deckSize = _data["deckSize"];
            this.frontCharacter = _data["frontCharacter"] ? CharacterCombatView.fromJS(_data["frontCharacter"]) : new CharacterCombatView();
            this.backCharacter = _data["backCharacter"] ? CharacterCombatView.fromJS(_data["backCharacter"]) : <any>undefined;
        }
    }

    static fromJS(data: any): BaseCombatSideView {
        data = typeof data === 'object' ? data : {};
        throw new Error("The abstract class 'BaseCombatSideView' cannot be instantiated.");
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["side"] = this.side;
        data["deckSize"] = this.deckSize;
        data["frontCharacter"] = this.frontCharacter ? this.frontCharacter.toJSON() : <any>undefined;
        data["backCharacter"] = this.backCharacter ? this.backCharacter.toJSON() : <any>undefined;
        return data;
    }
}

export interface IBaseCombatSideView {
    side: CombatSide;
    deckSize: number;
    frontCharacter: CharacterCombatView;
    backCharacter?: CharacterCombatView | undefined;
}

export class CombatSideView extends BaseCombatSideView implements ICombatSideView {

    constructor(data?: ICombatSideView) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
    }

    static override fromJS(data: any): CombatSideView {
        data = typeof data === 'object' ? data : {};
        let result = new CombatSideView();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export interface ICombatSideView extends IBaseCombatSideView {
}

export enum CombatSide {
    None = "none",
    Left = "left",
    Right = "right",
}

export class CharacterCombatView implements ICharacterCombatView {
    character!: CharacterView;
    health!: number;
    passiveEffects!: PassiveEffectInstanceView[];
    modifiers!: StatsModifier;

    constructor(data?: ICharacterCombatView) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.character = new CharacterView();
            this.passiveEffects = [];
            this.modifiers = new StatsModifier();
        }
    }

    init(_data?: any) {
        if (_data) {
            this.character = _data["character"] ? CharacterView.fromJS(_data["character"]) : new CharacterView();
            this.health = _data["health"];
            if (Array.isArray(_data["passiveEffects"])) {
                this.passiveEffects = [] as any;
                for (let item of _data["passiveEffects"])
                    this.passiveEffects!.push(PassiveEffectInstanceView.fromJS(item));
            }
            this.modifiers = _data["modifiers"] ? StatsModifier.fromJS(_data["modifiers"]) : new StatsModifier();
        }
    }

    static fromJS(data: any): CharacterCombatView {
        data = typeof data === 'object' ? data : {};
        let result = new CharacterCombatView();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["character"] = this.character ? this.character.toJSON() : <any>undefined;
        data["health"] = this.health;
        if (Array.isArray(this.passiveEffects)) {
            data["passiveEffects"] = [];
            for (let item of this.passiveEffects)
                data["passiveEffects"].push(item.toJSON());
        }
        data["modifiers"] = this.modifiers ? this.modifiers.toJSON() : <any>undefined;
        return data;
    }
}

export interface ICharacterCombatView {
    character: CharacterView;
    health: number;
    passiveEffects: PassiveEffectInstanceView[];
    modifiers: StatsModifier;
}

export class PassiveEffectInstanceView implements IPassiveEffectInstanceView {
    id!: string;
    effect!: PassiveEffectView;
    source!: string;
    remainingDuration!: number;

    constructor(data?: IPassiveEffectInstanceView) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.effect = new PassiveEffectView();
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.effect = _data["effect"] ? PassiveEffectView.fromJS(_data["effect"]) : new PassiveEffectView();
            this.source = _data["source"];
            this.remainingDuration = _data["remainingDuration"];
        }
    }

    static fromJS(data: any): PassiveEffectInstanceView {
        data = typeof data === 'object' ? data : {};
        let result = new PassiveEffectInstanceView();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["effect"] = this.effect ? this.effect.toJSON() : <any>undefined;
        data["source"] = this.source;
        data["remainingDuration"] = this.remainingDuration;
        return data;
    }
}

export interface IPassiveEffectInstanceView {
    id: string;
    effect: PassiveEffectView;
    source: string;
    remainingDuration: number;
}

export enum CombatSideTurnPhase {
    None = "none",
    StartOfTurn = "startOfTurn",
    Draw = "draw",
    Play = "play",
    EndOfTurn = "endOfTurn",
}

export class PlayerCombatView extends BaseCombatView implements IPlayerCombatView {
    player!: PlayerSideView;
    combat!: CombatSideView;

    constructor(data?: IPlayerCombatView) {
        super(data);
        if (!data) {
            this.player = new PlayerSideView();
            this.combat = new CombatSideView();
        }
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.player = _data["player"] ? PlayerSideView.fromJS(_data["player"]) : new PlayerSideView();
            this.combat = _data["combat"] ? CombatSideView.fromJS(_data["combat"]) : new CombatSideView();
        }
    }

    static override fromJS(data: any): PlayerCombatView {
        data = typeof data === 'object' ? data : {};
        let result = new PlayerCombatView();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["player"] = this.player ? this.player.toJSON() : <any>undefined;
        data["combat"] = this.combat ? this.combat.toJSON() : <any>undefined;
        super.toJSON(data);
        return data;
    }
}

export interface IPlayerCombatView extends IBaseCombatView {
    player: PlayerSideView;
    combat: CombatSideView;
}

export class PlayerSideView extends BaseCombatSideView implements IPlayerSideView {
    hand!: CardInstanceWithModifiersView[];

    constructor(data?: IPlayerSideView) {
        super(data);
        if (!data) {
            this.hand = [];
        }
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            if (Array.isArray(_data["hand"])) {
                this.hand = [] as any;
                for (let item of _data["hand"])
                    this.hand!.push(CardInstanceWithModifiersView.fromJS(item));
            }
        }
    }

    static override fromJS(data: any): PlayerSideView {
        data = typeof data === 'object' ? data : {};
        let result = new PlayerSideView();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.hand)) {
            data["hand"] = [];
            for (let item of this.hand)
                data["hand"].push(item.toJSON());
        }
        super.toJSON(data);
        return data;
    }
}

export interface IPlayerSideView extends IBaseCombatSideView {
    hand: CardInstanceWithModifiersView[];
}

export class CardInstanceView implements ICardInstanceView {

    constructor(data?: ICardInstanceView) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
    }

    static fromJS(data: any): CardInstanceView {
        data = typeof data === 'object' ? data : {};
        let result = new CardInstanceView();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        return data;
    }
}

export interface ICardInstanceView {
}

export class CardInstanceWithModifiersView extends CardInstanceView implements ICardInstanceWithModifiersView {
    baseCard!: ActionCardView;

    constructor(data?: ICardInstanceWithModifiersView) {
        super(data);
        if (!data) {
            this.baseCard = new ActionCardView();
        }
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.baseCard = _data["baseCard"] ? ActionCardView.fromJS(_data["baseCard"]) : new ActionCardView();
        }
    }

    static override fromJS(data: any): CardInstanceWithModifiersView {
        data = typeof data === 'object' ? data : {};
        let result = new CardInstanceWithModifiersView();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["baseCard"] = this.baseCard ? this.baseCard.toJSON() : <any>undefined;
        super.toJSON(data);
        return data;
    }
}

export interface ICardInstanceWithModifiersView extends ICardInstanceView {
    baseCard: ActionCardView;
}

export class CreateCombatRequest implements ICreateCombatRequest {
    opponentTeam!: string[];
    playerTeam!: string[];

    constructor(data?: ICreateCombatRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.opponentTeam = [];
            this.playerTeam = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["opponentTeam"])) {
                this.opponentTeam = [] as any;
                for (let item of _data["opponentTeam"])
                    this.opponentTeam!.push(item);
            }
            if (Array.isArray(_data["playerTeam"])) {
                this.playerTeam = [] as any;
                for (let item of _data["playerTeam"])
                    this.playerTeam!.push(item);
            }
        }
    }

    static fromJS(data: any): CreateCombatRequest {
        data = typeof data === 'object' ? data : {};
        let result = new CreateCombatRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.opponentTeam)) {
            data["opponentTeam"] = [];
            for (let item of this.opponentTeam)
                data["opponentTeam"].push(item);
        }
        if (Array.isArray(this.playerTeam)) {
            data["playerTeam"] = [];
            for (let item of this.playerTeam)
                data["playerTeam"].push(item);
        }
        return data;
    }
}

export interface ICreateCombatRequest {
    opponentTeam: string[];
    playerTeam: string[];
}

export class ApiException extends Error {
    override message: string;
    status: number;
    response: string;
    headers: { [key: string]: any; };
    result: any;

    constructor(message: string, status: number, response: string, headers: { [key: string]: any; }, result: any) {
        super();

        this.message = message;
        this.status = status;
        this.response = response;
        this.headers = headers;
        this.result = result;
    }

    protected isApiException = true;

    static isApiException(obj: any): obj is ApiException {
        return obj.isApiException === true;
    }
}

function throwException(message: string, status: number, response: string, headers: { [key: string]: any; }, result?: any): Observable<any> {
    if (result !== null && result !== undefined)
        return _observableThrow(result);
    else
        return _observableThrow(new ApiException(message, status, response, headers, null));
}

function blobToText(blob: any): Observable<string> {
    return new Observable<string>((observer: any) => {
        if (!blob) {
            observer.next("");
            observer.complete();
        } else {
            let reader = new FileReader();
            reader.onload = event => {
                observer.next((event.target as any).result);
                observer.complete();
            };
            reader.readAsText(blob);
        }
    });
}